<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>RestLess &mdash; Module de cours: guide</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Module de cours: guide" href="index.html" />
    <link rel="next" title="Affichage des mathématiques" href="maths.html" />
    <link rel="prev" title="Modèle relationnel" href="models.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="maths.html" title="Affichage des mathématiques"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="models.html" title="Modèle relationnel"
             accesskey="P">précédent</a> |</li>
        <li><a href="index.html">Module de cours: guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="restless">
<h1>RestLess<a class="headerlink" href="#restless" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="presentation">
<h2>Présentation<a class="headerlink" href="#presentation" title="Lien permanent vers ce titre">¶</a></h2>
<p><a class="reference external" href="https://github.com/dobarkod/django-restless">RestLess</a> est un set d&#8217;outils permettant de faciliter l&#8217;implémentation d&#8217;une API JSON dans Django. Il a l&#8217;avatange d&#8217;être léger et facile à utiliser comme nous le verrons par la suite. Une API - Application Programming Interface - est basiquement une application qui offre des services accessible par une autre application et le JSON est un format de données dans le style d&#8217;un dictionnaire <tt class="docutils literal"><span class="pre">{&quot;nom&quot;</span> <span class="pre">:</span> <span class="pre">&quot;Keran&quot;,</span> <span class="pre">&quot;prenom&quot;</span> <span class="pre">:</span> <span class="pre">&quot;Kocher&quot;}</span></tt>. On appelle donc une API JSON, une application qui fournit des données en format JSON. Concrétement il s&#8217;agit d&#8217;une série d&#8217;URLs qui fournissent le contenu de différentes tables de la BD en format JSON. Quand on se rend sur une de ces URLs, on ne voit pas une page HTML comme on a l&#8217;habitude de voir, mais simplement le dictionnaire de données affiché. Sur notre site web rendez-vous sur <a class="reference external" href="http://webmath.com/courses/api/themes">http://webmath.com/courses/api/themes</a> pour voir à quoi cela ressemble.</p>
<p>Dans la présentation concernant AngularJS, nous avons vu que le framework n&#8217;était pas capable de communiquer directement avec une base de données, c&#8217;est une limitation de JavaScript, qui s&#8217;exécute côté client - sur l&#8217;ordinateur de l&#8217;utilisateur, opposé de côté serveur - dans notre cas. Pour palier ce problème on utilise donc un language intermédiaire qui est capable de communiquer avec une BD et qui s&#8217;exécute côté serveur, c&#8217;est le cas de Python et son framework Django. Django va donc chercher les données dans la BD, les transforme en format JSON puis les sert. Il suffit ensuite pour AngularJS d&#8217;accéder à la bonne URL et elle dispose ensuite des données qu&#8217;on peut utiliser à notre guise.</p>
</div>
<div class="section" id="les-vues-generiques">
<h2>Les vues génériques<a class="headerlink" href="#les-vues-generiques" title="Lien permanent vers ce titre">¶</a></h2>
<p>Quand on développe une application pour web, il arrive souvent d&#8217;avoir du code redondant, répétitif. En effet quand on crée des fonctionnalités, il s&#8217;agit souvent d&#8217;avoir une table dans la base de données puis d&#8217;interréagir avec celle-ci ensuite pour modifer les données. Et ces interractions sont généralement toujours les mêmes, on parle généralement du CRUD: create, read, update and delete ou en français créer, lire, mettre à jour et supprimer. On aura donc une table et on voudra accomplir les opérations CRUD dessus et pour ce faire on aura une série d&#8217;URLs et d&#8217;actions derrières. Prenons l&#8217;exemple de la création d&#8217;un blog tout à fait typique: on va créer une table <tt class="docutils literal"><span class="pre">articles</span></tt> et on va implémenter les actions suivantes: on veut pourvoir afficher tous les articles ou pouvoir en afficher un seul - read, ajouter un nouvel article - create, le mettre à jour - update - ou le supprimer - delete. Et voilà, avec ces 4 opérations on peut disposer d&#8217;un blog complet et fonctionnel. Et pour beaucoup de fonctionnalité il s&#8217;agira d&#8217;effectuer toujours ces mêmes opérations classiques, imaginez par exemple un système de commentaires ou alors d&#8217;événements. Pour programmer ces outils basiques et conventionnels deux moyens sont à notre disposition dans Django. Soit on programme de A à Z les opérations, avec Django il s&#8217;agit basiquement de créer une URL et lui assigner une fonction qui retourne du code HTML et qui s&#8217;occupe de communiquer avec la base de données. Si on utilise cette méthode, on risque de devoir programmer souvent le même code au fil du développement et de perdre du temps. Ci-dessous le code pour afficher tous les articles avec la méthode normale.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># url.py - fichier qui gère les URLs du site</span>

<span class="kn">from</span> <span class="nn">django.conf.urls</span> <span class="kn">import</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">include</span>

<span class="kn">from</span> <span class="nn">courses</span> <span class="kn">import</span> <span class="n">views</span>

<span class="c"># on crée une URL /articles qui utilise la fonction index - voir fichier views.py</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="n">patterns</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span>
    <span class="n">url</span><span class="p">(</span><span class="s">r&#39;^articles$&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
<span class="p">)</span>

<span class="c"># views.py - fichier qui contient les fonctions liées aux URLs</span>
<span class="c"># = vue ou controlleur</span>

<span class="kn">from</span> <span class="nn">django.shortcuts</span> <span class="kn">import</span> <span class="n">render</span>

<span class="c"># fonction reliée à /articles</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c"># Récupère tous les articles de la BD (fait appelle au modèle Article)</span>
    <span class="n">articles</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="c"># Retourne le code HTML en utilisant le ficher courses.html</span>
    <span class="k">return</span> <span class="n">render</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="s">&quot;courses/courses.html&quot;</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>
</pre></div>
</div>
<p>La deuxième méthode consiste à utiliser les vues génériques. Ce sont en effet des classes que Django possède contenant déjà les opérations conventionnelles déjà écrites. Il nous suffit donc de créer notre propre classe qui hérite des classes Django, des vues génériques et d&#8217;ensuite la relier à notre URL comme on le faisait avec la fonction. Pourquoi créer une classe et ne pas utiliser directement les classes Django ? Tout simplement pour pouvoir personnaliser la classe. Il faut déjà obligatoirement spécifier le modèle que doit utiliser la classe par exemple pour savoir quelles enregistremens elle doit aller récupérer. Voici donc la même fonctionnalité qu&#8217;avant mais avec les vues génériques.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># url.py - fichier qui gère les URLs du site</span>

<span class="kn">from</span> <span class="nn">django.conf.urls</span> <span class="kn">import</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">include</span>

<span class="kn">from</span> <span class="nn">courses.views</span> <span class="kn">import</span> <span class="n">ArticlesList</span>

<span class="c"># on crée une URL /articles qui utilise la vue générique ArticlesList - voir fichier views.py</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="n">patterns</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span>
    <span class="n">url</span><span class="p">(</span><span class="s">r&#39;^articles$&#39;</span><span class="p">,</span> <span class="n">ArticlesList</span><span class="o">.</span><span class="n">as_view</span><span class="p">()),</span>
<span class="p">)</span>

<span class="c"># views.py - fichier qui contient les fonctions liées aux URLs</span>
<span class="c"># = vue ou controlleur</span>

<span class="kn">from</span> <span class="nn">django.views.generic</span> <span class="kn">import</span> <span class="n">ListView</span>

<span class="c"># la classe générique reliée à /articles</span>
<span class="c"># Hérite de ListView, classe provenant de Django</span>
<span class="k">class</span> <span class="nc">ArticlesList</span><span class="p">(</span><span class="n">ListView</span><span class="p">):</span>

    <span class="c"># on spécifie le modèle à utiliser</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Article</span>
</pre></div>
</div>
<p>Avec la seconde méthode le code est plus concis. L&#8217;exemple montre comment générer une liste d&#8217;articles, mais il existe une classe pour chaque opération du CRUD. Il est encore possible de personnaliser notre classe <tt class="docutils literal"><span class="pre">ArticlesList</span></tt> avec des options ou en surchargeant les méthodes. Par contre évidement que si notre fonctionnilité a des besoins spécifiques qui s&#8217;éloignent trop de la convention, les vues génériques ne sont plus adaptées car leur personnalisation a évidemment des limites. Dans ces cas-ci on retourne à la première méthode.</p>
</div>
<div class="section" id="fonctionnement-de-restless">
<h2>Fonctionnement de RestLess<a class="headerlink" href="#fonctionnement-de-restless" title="Lien permanent vers ce titre">¶</a></h2>
<p>Si nous avons étudié ce qu&#8217;étaient les vues génériques dans Django, c&#8217;est parce que RestLess se base exclusivement la-dessus pour construire une API JSON. En fait, RestLess fournit également des vues génériques qui sont dérivées des classes Django. Les classes de RestLess fonctionnent en effet exactement la même chose que celle de Django, à la différence qu&#8217;elles travaillent avec le format JSON. Ainsi on peut construire facilement et rapidement notre API, en économisant du code et du temps. Par contre Django possède beaucoup de vues génériques et RestLess n&#8217;offrent que les plus utiles. Avant de s&#8217;intéresser aux classes que nous pouvons utiliser avec RestLess, il faut d&#8217;abord voir les différentes types de requêtes qui existent dans le monde du web.</p>
<div class="section" id="http">
<h3>HTTP<a class="headerlink" href="#http" title="Lien permanent vers ce titre">¶</a></h3>
<p>HTTP est l&#8217;abréviation de <em>HyperText Transfer Protocol</em> qui veut dire <em>protocole de transfert hypertexte</em>. C&#8217;est ce protocole qui est utilisé sur internet pour la communication entre un client et un serveur. Le serveur est un ordinateur dont le rôle est de fournir le contenu désiré d&#8217;un site web et le client est un navigateur utilisé par une personne qui se connecte sur un site web. Lorsque qu&#8217;un utilisateur visite une page, le navigateur internet demande au serveur la page HTML correspondante et ensuite il l&#8217;affiche à l&#8217;utilisateur. Pour établir le transfert de données on utilise donc HTTP. Quand le client demande une information au serveur, on appelle cela une requête HTTP. Il y a plusieurs types de requête HTTP car nous avons vu que le serveur envoie des données au client, mais le contraire est aussi vrai, le client peut envoyer des données au serveur, quand il soumet un formulaire par exemple. Ces différentes requêtes, formulées par un navigateur qui est le client, servent en général à agir sur une ressource - une ressource est une entité modifiable, souvent un enregistrement provenant d&#8217;une BD - en permettant notamment les opérations de base, le CRUD. Voici la liste des différentes requêtes les plus importantes dans notre cas.</p>
<ul class="simple">
<li>GET: requête la plus courante, le serveur envoie les données au client, une page HTML par exemple. Aucune ressource modifié.</li>
<li>POST: le client envoie des données au serveur, souvent via un formulaire HTML. Le résultat est la création d&#8217;une ressource.</li>
<li>PUT: le client envoie des données au serveur. Le résultat est une modification d&#8217;une ressource.</li>
<li>DELETE: supprime une ressource.</li>
</ul>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/http.png"><img alt="_images/http.png" src="_images/http.png" style="width: 896.0px; height: 350.0px;" /></a>
<p class="caption">Schéma de la communication entre un client et un serveur</p>
</div>
<p>Nous devons utiliser ces requêtes lorsqu&#8217;il s&#8217;agit de modifier nos ressources, c&#8217;est-à-dire les enregistrements de notre base de données, par exemple quand on crée un cours ou qu&#8217;on le supprimme. Nous verrons plus tard comment on réalise ces requêtes avec AngularJS car maintenant le travail avec RestLess est de supporter ces requêtes, en clair d&#8217;avoir une URL et une fonction qui s&#8217;occupe de traiter les différentes requêtes. Attention à ne pas confondre, la requête n&#8217;agit pas directement sur la ressource, c&#8217;est le serveur qui s&#8217;en occupe, la requête consiste juste en un transfert de données entre le client et le serveur.</p>
</div>
<div class="section" id="les-classes-restless">
<h3>Les classes RestLess<a class="headerlink" href="#les-classes-restless" title="Lien permanent vers ce titre">¶</a></h3>
<p>Maintenant que les bases sont en place, nous pouvons enfin nous intéresser à la liste des classes RestLess utilisés dans le projet avec les requêtes supportées et leur utilité.</p>
<ul>
<li><p class="first">ListEndpoint</p>
<blockquote>
<div><ul class="simple">
<li>get: retourne toutes les ressources</li>
<li>post: crée une nouvelle ressource</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">DetailEndpoint</p>
<blockquote>
<div><ul class="simple">
<li>get: retourne une ressource</li>
<li>put: met à jour la ressource</li>
<li>delete: supprime la ressource</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Voici donc les deux vues génériques dont nos classes pourront hérités et qui permettent de réaliser les quatres opérations sur nos ressources. La différence entre les deux classes est que <tt class="docutils literal"><span class="pre">DetailEndpoint</span></tt> travaille une ressource en particulier, elle a donc besoin d&#8217;un identifiant dans l&#8217;URL pour savoir quelle ressource elle doit modifié, dans le style <tt class="docutils literal"><span class="pre">/courses/:id</span></tt>. Notez qu&#8217;évidemment toutes les actions - le code qui s&#8217;éxécute derrière une URL - RestLess retournent du JSON, étant donné que c&#8217;est sa particularité et son utilité. Comment concrétement utiliser ces classes dans le projet ? Comme précédement dans l&#8217;exemple avec les vues génériques Django, la première étape consiste à créer une classe qui hérite soit de <tt class="docutils literal"><span class="pre">ListEndpoint</span></tt> soit de <tt class="docutils literal"><span class="pre">DetailEndpoint</span></tt> et de spécifier le modèle. Ensuite il faut créer une url dans laquelle on spécifie qu&#8217;il faut utiliser notre classe précédemment déclarée. A partir de là, quand on fait une requête sur cette url, suivant le type, Django fera appelle aux méthodes provenant des vues génériques RestLess. Par exemple, on crée une classe <tt class="docutils literal"><span class="pre">CoursesList</span></tt> dans laquelle on spécifie le modèle <tt class="docutils literal"><span class="pre">Course</span></tt>. Ensuite on rattache cette classe à l&#8217;url <tt class="docutils literal"><span class="pre">/courses</span></tt>. Si on fait une requête de type POST sur <tt class="docutils literal"><span class="pre">/courses</span></tt>, Django va cherche la méthode <tt class="docutils literal"><span class="pre">post</span></tt> - même nom que le type de requête - dans la classe <tt class="docutils literal"><span class="pre">CoursesList</span></tt> puis dans son parent <tt class="docutils literal"><span class="pre">ListEndpoint</span></tt> et va l&#8217;exécuter, le résultat sera qu&#8217;une ressource sera créée dans la table <tt class="docutils literal"><span class="pre">courses</span></tt> avec les paramètres du client et une réponse en JSON contenant la ressource crée sera retournée. Ou alors on peut faire une requête GET sur <tt class="docutils literal"><span class="pre">/courses</span></tt> et le serveur retourne tous les cours en format JSON également. Rien de plus n&#8217;est nécessaire pour avoir notre API JSON fonctionnel.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/requetes.png"><img alt="_images/requetes.png" src="_images/requetes.png" style="width: 896.0px; height: 490.0px;" /></a>
<p class="caption">Schéma du traitement d&#8217;une requête à l&#8217;aide des vues génériques RestLess</p>
</div>
<p>Dans le cas de notre projet, il a fallu personnaliser les vues génériques pour répondre aux besoins spécifiques de la ressource. Pour ce faire on doit surcharger les methodes intégrées RestLess. Vous avez pu remarquer que les méthodes ont le nom de la requête auxquelle elles correspondent. Si on fait une requête PUT, la méthode <tt class="docutils literal"><span class="pre">put</span></tt> est appelée et ainsi de suite. C&#8217;est un principe dans les vues génériques Django. Concernant nos vues génériques, si notre une classe ne contient pas le méthode appelée par une requête, le framework va automatiquement chercher la méthode dans la classe parent, c&#8217;est-à-dire dans la classe RestLess qui contient les méthodes classiques et conventionnelles et qui nous évite un code redondant. Par contre si on ne veut plus utiliser ces méthodes classiques car elles ne sont plus adaptées, alors on crée une méthode de même nom dans la classe fille et c&#8217;est désormais cette méthode qui sera appelé lorsqu&#8217;elle est appelé d&#8217;une instance de notre classe fille. C&#8217;est ce qu&#8217;on appelle surcharger une méthode. Dans le projet, toutes les vues générques sont écrites dans le fichier <tt class="docutils literal"><span class="pre">api.py</span></tt>. On peut y observer que plusieurs méthodes de tout type, get, post, put, ont été surchargées. On peut s&#8217;inspirer des méthodes RestLess qu&#8217;on surcharge pour que notre fonction accèpte les bons arguments et retourne une réponse valide en se rendant sur le <a class="reference external" href="https://django-restless.readthedocs.org/en/latest/_modules/restless/modelviews.html">fichier source</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/surcharge.png"><img alt="_images/surcharge.png" src="_images/surcharge.png" style="width: 896.0px; height: 490.0px;" /></a>
<p class="caption">Surcharge d&#8217;une méthode</p>
</div>
<p>On doit parfois retourner des objets JSON personnalisés, c&#8217;est-à-dire pouvoir choisir les paires clé/valeur de notre dictionnaire, car par défaut RestLess retourne simplement les attributs de l&#8217;enregistrement en question. On accomplit cela généralement dans le but de choisir les attributs, d&#8217;en créer des nouveaux qui ne sont pas des champs de la table ou de joindre des enregistrements associés dans la BD. RestLess fournit la méthode <tt class="docutils literal"><span class="pre">serialize</span></tt> pour résoudre ce problème. Par exemple pour un cours nous avons besoin de joindre les pages associées (=objets associés) et leur contenu ainsi que le nombre total de pages (=nouvel attribut créé). Voir <a class="reference external" href="https://django-restless.readthedocs.org/en/latest/#">la documentation</a> pour plus d&#8217;informations et le fichier <tt class="docutils literal"><span class="pre">api.py</span></tt> pour des exemples d&#8217;utilisation.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table des Matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">RestLess</a><ul>
<li><a class="reference internal" href="#presentation">Présentation</a></li>
<li><a class="reference internal" href="#les-vues-generiques">Les vues génériques</a></li>
<li><a class="reference internal" href="#fonctionnement-de-restless">Fonctionnement de RestLess</a><ul>
<li><a class="reference internal" href="#http">HTTP</a></li>
<li><a class="reference internal" href="#les-classes-restless">Les classes RestLess</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Sujet précédent</h4>
  <p class="topless"><a href="models.html"
                        title="Chapitre précédent">Modèle relationnel</a></p>
  <h4>Sujet suivant</h4>
  <p class="topless"><a href="maths.html"
                        title="Chapitre suivant">Affichage des mathématiques</a></p>
  <h3>Cette page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/restless.txt"
           rel="nofollow">Montrer la source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Recherche rapide</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Saisissez un mot clef ou un nom de module, classe ou fonction.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="maths.html" title="Affichage des mathématiques"
             >suivant</a> |</li>
        <li class="right" >
          <a href="models.html" title="Modèle relationnel"
             >précédent</a> |</li>
        <li><a href="index.html">Module de cours: guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Keran Kocher.
      Créé avec <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>